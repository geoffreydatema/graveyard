::{
    debug&m&v{print('DEBUG: {m} : {v}');}
    print&data{>>data;->$;}
    scan&prompt{x<<prompt;->x;}
    hello{>>"hello world!";->$;}
    len&data{c=0;?(@@data)=="string"||(@@data)=="array"||(@@data)=="hashtable"{i@data{c++;}->c;}:{!>>'len(): cannot get length of {@@data}';}}
    stoa&s{a=[];i@s{a+=[i];}->a;}
    append&a&v{?(@@a)=="array"{->a+[v];}}
    prepend&a&v{?(@@a)=="array"{->[v]+a;}}
    pop&a{x=[];l=len(a)-1;i@0,len(a){?i==l{->x;}x+=[a[i]];}}
    remove&a&x{r=[];i@0,len(a){?i==x{^;}r+=[a[i]];}->r;}
    insert&a&v&x{l=len(a);?x>l-1{!>>"insert(): cannot insert beyond the size of the array";}r=[];i@0,l{?i==x{r+=[v];}r+=[a[i]];}->r;}
    last&d{?(@@d=="string"){a=stoa(d);->a[len(a)-1];}}
    join&a{s="";i@a{s+=>si;}->s;}

    rdig {
        ->last(>s:@);
    }

    rint&min&max{
        s = "";
        i @ 0,len(>s max) {
            s += rdig();
        }
        -> ((>i s) /% ((max - min) + 1)) + min;
    }

    fastrint&min&max{
        t = >s :@ + "00";
        array = stoa(t);
        indicies = [];

        integer = |;
        ? len(array) > 15 {
            indicies = append(indicies, array[13]);
            indicies = append(indicies, array[14]);
            indicies = append(indicies, array[15]);
            integer = (>i join(indicies)) * 18446744073709551615;
        } : {
            !>>"fastrint(): could not generate random integer due to an internal error";
        }

        ->(integer /% ((max - min) + 1)) + min;

    }

    rfloat {
        s = "0.";
        i @ 0,8 {
            s += rdig();
        }
        -> >f s;
    }


    // rstr {}

    /*
    def execute_magic_number(self):
        return random.randint(10000000, 99999999)

    def execute_magic_weight(self):
        return round(random.random(), 8)
    
    def execute_magic_uid(self):
        return str(hex(random.randint(286331153, 4294967295)))[2:]
    
    def execute_magic_string(self):
        characters = "!#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"
        return "".join(random.choice(characters) for i in range(16))

    def execute_stoa(self, args):
        return list(self.execute(args[0]))
    
    def execute_reverse(self, args):
        values = []
        if isinstance(args, list):
            values = self.execute(args[0])
        return values[::-1]

    def execute_range(self, primitive):
        start = self.execute(primitive.start)
        end = self.execute(primitive.end)

        if type(start) != int:
            start = int(start)
        if type(end) != int:
            end = int(end)

        if start < end:
            return list(range(start, end + 1))
        elif start > end:
            return list(range(start, end - 1, -1))
        elif start == end:
            return [start]
    */

}