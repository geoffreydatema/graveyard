::{
    debug&m&v{print('DEBUG: {m} : {v}');}
    print&data{>>data;->$;}
    scan&prompt{x<<prompt;->x;}
    hello{>>"hello world!";->$;}
    len&data{c=0;?(@@data)=="string"||(@@data)=="array"||(@@data)=="hashtable"{i@data{c++;}->c;}:{!>>'len(): cannot get length of {@@data}';}}
    stoa&s{a=[];i@s{a+=[i];}->a;}
    append&a&v{?(@@a)=="array"{->a+[v];}}
    prepend&a&v{?(@@a)=="array"{->[v]+a;}}
    pop&a{x=[];l=len(a)-1;i@0,len(a){?i==l{->x;}x+=[a[i]];}}
    remove&a&x{r=[];i@0,len(a){?i==x{^;}r+=[a[i]];}->r;}
    insert&a&v&x{l=len(a);?x>l-1{!>>"insert(): cannot insert beyond the size of the array";}r=[];i@0,l{?i==x{r+=[v];}r+=[a[i]];}->r;}
    last&d{?(@@d=="string"){a=stoa(d);->a[len(a)-1];}}
    join&a{s="";i@a{s+=>si;}->s;}
    rdig{->last(>s:@);}
    rdigseq&l{s="";i@0,l{s+=rdig();}->s;}
    rfloat{s="";i@0,8{s+=rdig();}->>f("0."+s);}
    rint&l&u{f=rfloat();r=u-l+1;s=f*r;->>i(s + l);}
    rstr&l{chars = ["!","#","$","%","&","'","(",")","*","+",",","-",".","/","0","1","2","3","4","5","6","7","8","9",":",";","<","=",">","?","@","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","[","]","^","_","`","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","{","|","}","~"];s="";i@0,l{s+=chars[rint(0,91)];}->s;}

    /*
    def execute_magic_number(self):
        return random.randint(10000000, 99999999)

    def execute_magic_weight(self):
        return round(random.random(), 8)
    
    def execute_magic_uid(self):
        return str(hex(random.randint(286331153, 4294967295)))[2:]
    
    def execute_magic_string(self):
        characters = "!#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"
        return "".join(random.choice(characters) for i in range(16))

    def execute_stoa(self, args):
        return list(self.execute(args[0]))
    
    def execute_reverse(self, args):
        values = []
        if isinstance(args, list):
            values = self.execute(args[0])
        return values[::-1]

    def execute_range(self, primitive):
        start = self.execute(primitive.start)
        end = self.execute(primitive.end)

        if type(start) != int:
            start = int(start)
        if type(end) != int:
            end = int(end)

        if start < end:
            return list(range(start, end + 1))
        elif start > end:
            return list(range(start, end - 1, -1))
        elif start == end:
            return [start]
    */

}